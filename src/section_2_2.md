# 函数

`def` 构造不仅允许定义常量，还允许定义函数。

```haskell
def square x = x ^ 2;

square 4 = 16;
```

函数的名称由 `def` 之后的第一个标记表示。函数应用并置(juxtaposition)表示，类似于某些函数式语言（如Haskell）。

在编译期间，类型检查器将标识 `square` 的类型为从 int 到 int 的函数。

```bash
> square[3]: (int -> int)
```

函数可以有多个参数。

```haskell
def f x y z = x * z + y;

f 4 5 6 = 29;
```

此函数的类型指示多个参数。

```bash
> f[5]: (int -> (int -> (int -> int)))
```

这告诉我们每个参数都会接受一个整数并产生一个函数，直到第三个参数，之后它会产生一个整数。 这表明应用程序是左关联的，并且默认情况下函数是柯里化的（更多信息请参见[高阶函数]（section_2_6.md）部分）。


```haskell
((f 4) 5) 6 = f 4 5 6;
```

定义中可以包含定义。

```haskell
def g x = {
  def k = 20;
  x * k
};

g 3 = 60;
```

请注意使用花括号来定义函数范围内的块。 另外，请注意定义的分号出现在右大括号之后，并且大括号之前的最后一行没有分号。

内部 `def` 语句的使用方式应类似于许多函数式语言中常见的 `let` 语句。 内部 `def` 语句也可以是函数。

```haskell
def cube x = {
  def square x = x * x;
  x * square x
};

cube 3 = 27;
```

编译期间不会给出内部 `def` 语句的类型，但仍会对其进行检查。

定义中的行数或嵌套数没有限制。

```haskell
def power x = {
  def hypercube x = {
    def square x = x * x;
    square (square x)
  };
  def cube x = {
    def square x = x * x;
    x * square x
  };
  cube (hypercube x)
 };

power 2 = 4096;
```

允许重复命名。 对名称的引用将引用最近的绑定。

```haskell
def x = 4;
def x = 8;
x = 8;
```

在类型检查时，所有变量都是线性的。

```bash
> x[2]: int
> x[3]: int
```

在某种意义上，名称旁边的数字是变量的“真实”名称。 每个变量都有一个唯一的编号来标识它，允许系统避免混淆具有相同名称的变量。

等式(Equations)也可以出现在定义中。 定义可能会或可能不会返回一个值，并且可以充当其他值的门电路。

```haskell
def g1 x = {x = 4; x};
g1 4;

def g2 x = {x = 10};
g2 10;
```

看看这些类型，就会发现一些有趣的东西。

```bash
> g2[5]: (int -> ())
```

事实上， `g2` 会返回一个 `()` 类型的值。这将在有关 [元组](section_2_3.md) 的部分中进行解释。

这说明 Vamp-IR 文件不需要任何顶级函数，但仍将通过函数调用强制执行的等式表示一个命题。 在这种情况下，`g1 5;` 将产生无效证明。

如果从未实际调用等式的父函数，则不会强制执行等式。

```haskell
def j x = {0 = 1; x};

1 = 1;
```

将产生一个有效的证明，因为 `j` 从未被完全实例化。 当它们的父函数被完全实例化时，等式式成为电路的一部分。 `def k = {0 = 1; 4};` **将**产生无效证明，因为 `k` 已经完全实例化。

使用多项式约束，可以创建复杂的、可重复使用的检查。 例如，以下检查字段元素是否为布尔值： 0 或 1。

```haskell
def isBool x = { 
  (x - 1) * x = 0;
  x
};

isBool 0;
isBool 1;
```

可以在定义中创建需要请求的 wintness。 例如:

```haskell
def j x = x * y;

j 5 = 20;
```

将为 y 请求一个值。 值得注意的是，wintness 不受定义范围的约束； 它们是全局的，无论它们在何处被引用。 这意味着


```haskell
def j x = x * y;

j 5 = j 5;
```

只会为 `y` 请求一个值，并且该值将用于对 `j` 的两次调用。
