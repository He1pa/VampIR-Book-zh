# 基本算术运算

Vamp-IR 的算术运算表示相当简单，与许多主流语言中的算术表示非常相似。

Vamp-IR 提供了四种不同的方法来表示数字。 可以用:

1. 标准十进制
2. 十六进制表示法，数字以 `0x` 为前缀
3. 八进制表示法，数字以 `0o` 为前缀
4. 二进制表示法，数字以 `0b` 为前缀

下面的示例程序演示了所有的数字符号表示。

```haskell
0xee9a592ba9a9518 = 1074572035719075096;
1074572035719075096 = 0o73515131127246512430;
0o73515131127246512430 = 0b111011101001101001011001001010111010100110101001010100011000;
```

请注意，Vamp-IR 允许在同一个程序中使用许多顶级方程(top-level equations)。

可以分别使用中缀运算符 `+`、`-` 和 `*` 对数字进行加法、减法和乘法运算。

```haskell
20 * 3 - 20 = 20 + 20;
```

Vamp-IR 使用标准的运算顺序，其中乘法优先于加法和减法，否则一切都是左关联的。可以使用括号进行进一步说明。

```haskell
1 + 2 + 3 - 4 * 5 - 6 + 7 =
((((1 + 2) + 3) - (4 * 5)) - 6) + 7;
```

Vamp-IR 还允许在算术电路中进行除法，用中缀运算符 `/` 表示。

```haskell
15/3 = 5;
```

除法与乘法具有相同的优先级，并且联合在左边，否则：

```haskell
2/3*4/5 = ((2/3)*4)/5;
```

这个操作将使用底层字段的除法给出一个输出，这意味着约束在编译目标上的真值可能会有所不同。如果使用如下大小的素域：

`52435875175126190479447740508185965837690552500527637822603658699938581184513`,

例如在BLS12-381中使用，则以下内容是有效的：

```haskell
2/3 = 0x26a48d1bb889d46d66689d580335f2ac713f36abaaaa1eaa5555555500000001;
```

如果有人尝试除以零，他们会在过程中的某个时间点出现错误，具体取决于除法发生的位置。 `1/0 = 1;` 将在类型推断期间产生错误。 如果在证人请求期间将 `x` 设置为 0，`1/x = 1;` 将产生错误。

Vamp-IR 还拥有一个否定形式的一元运算，用“-”表示。 除非与其他取反一起迭代，否则必须用括号括起来。

```haskell
(-10) = 0 - 10;
0 - 10 = (---10);
```

求幂也可以通过中缀运算符 `^` 获得。

```haskell
2 ^ 2 = 4;
```

求幂比任何其他算术运算符都具有更高的优先级。

```haskell
5 * 6 ^ 7 = 5 * (6 ^ 7);
```

只允许常数指数，因为它们可以在电路编译时转换为迭代乘法。 `2 ^ x = 4;` 将在类型推断期间产生错误。

以 0 求幂将始终产生 1，即使基数为 0。

```haskell
2 ^ 0 = 1;
0 ^ 0 = 1;
0 ^ 2 = 0;
```

<p style="color:red;">注意：本节可能描述错误而不是预期行为</p>

负数求幂有点奇怪。 它们与人们的预期相差 1。

```haskell
2 ^ (-5) = 1 / 2 ^ 4;
6 ^ (-2) = 1 / 6;
5 ^ (-3) = 1 / 5 ^ 2;
```

用 -1 求幂将始终产生 1，但 0 除外。

```haskell
2 ^ (-1) = 1;
6 ^ (-1) = 1;
5 ^ (-1) = 1;
0 ^ (-1) = 0;
```

只要电路可以被转换，使它们不被引用，就可以使用一些额外的算术运算符。这些运算符将在[扩展算术](section_3_2.md) 部分详细介绍。 现在，模数 `%` 将用作示例。

```haskell
6 = 15 % 9;
```

这将创建一个有效的证明。 这是因为在电路生成过程中，`15 % 9` 可以立即简化为 `6`。 如果有人试图使用一个未实例化的变量，即没有在文件中定义值的变量，他们将得到一个错误。

```haskell
6 = x % 9;
```

这将在电路创建期间生成错误，通知我们取模的约束不被支持。
