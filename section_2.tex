\section{Programming in \vampir}

\subsection{Basic Arithmetic}

\vampir's arithmetic denotations are fairly straightforward, being very similar to what's present in many mainstream languages.

\vampir\ provides four different methods to denote numbers. One can use

\begin{itemize}
  \item standard decimal notation
  \item hexadecimal notation, so long as the number is prefixed by \lstinline{0x}
  \item octal notation, so long as the number is prefixed by \lstinline{0o}
  \item binary notation, so long as the number is prefixed by \lstinline{0b}
\end{itemize}

The following example program demonstrates all the number notations.

\begin{lstlisting}[language=Python]
  0xee9a592ba9a9518 = 1074572035719075096;
  1074572035719075096 = 0o73515131127246512430;
  0o73515131127246512430 =
  0b111011101001101001011001001010111010100110101001010100011000;
\end{lstlisting}

Notice that \vampir\ allows for many top-level equations in the same program.

One can add, subtract, and multiply numbers, using, respectively, the infix operators \lstinline{+}, \lstinline{-}, and \lstinline{*}.

\begin{lstlisting}[language=Python]
  20 * 3 - 20 = 20 + 20;
\end{lstlisting}

\vampir\ uses a standard order of operations where multiplication takes precedence over addition and subtraction, and everything is left-associated otherwise. Further clarification can be made using parentheses.

\begin{lstlisting}[language=Python]
  1 + 2 + 3 - 4 * 5 - 6 + 7 =
  ((((1 + 2) + 3) - (4 * 5)) - 6) + 7;
\end{lstlisting}

\vampir\ also allows for division in arithmetic circuits, denoted with the infix operator \lstinline{/}.

\begin{lstlisting}[language=Python]
  15/3 = 5;
\end{lstlisting}

Division has the same precedence as multiplication, and associates to the left, otherwise. 

\begin{lstlisting}[language=Python]
  2/3/4/5 = ((2/3)/4)/5;
\end{lstlisting}

This operation will give an output using the division of the underlying field, meaning constraints may differ in truth value depending on the compilation target. If one uses a prime field of size

52435875175126190479447740508185965837690552500527637822603658699938581184513,

used, for example, in BLS12-381, then the following is valid.

\begin{lstlisting}[language=Python]
  2/3 = 0x26a48d1bb889d46d66689d580335f2ac713f36abaaaa1eaa5555555500000001;
\end{lstlisting}
  
If one tries dividing by zero, they will get an error at some point in the process depending on where the division occurs. \lstinline{1/0 = 1;} will produce an error during type inference. \lstinline{1/x = 1;} will produce an error if `x' is set to 0 during witness solicitation.

\vampir\ also possesses a single unary operation in the form of negation, denoted with \lstinline{-}. Negation must be surrounded by parentheses unless it's iterated with additional negations.

\begin{lstlisting}[language=Python]
  (-10) = 0 - 10;
  0 - 10 = (---10);
\end{lstlisting}

Exponentiation is also available via the infix operator \lstinline{^}.

\begin{lstlisting}[language=Python]
  2 ^ 2 = 4;
\end{lstlisting}

Exponentiation has greater precedence than any other arithmetic operator. 

\begin{lstlisting}[language=Python]
  5 * 6 ^ 7 = 5 * (6 ^ 7);
\end{lstlisting}

Only constant exponents are allowed, as they can be translated into iterated multiplication. \lstinline{2 ^ x = 4;} will create an error during type inference.

Exponentiation by 0 will always produce 1, even if the base is 0.

\begin{lstlisting}[language=Python]
  2 ^ 0 = 1;
  0 ^ 0 = 1;
  0 ^ 2 = 0;
\end{lstlisting}

\textcolor{red}{[Note: this section may describe a bug instead of intended behaviour]}

Exponentiation by negatives is a bit weird. They are offset by 1 from what one might expect.

\begin{lstlisting}[language=Python]
  2 ^ (-5) = 1 / 2 ^ 4;
  6 ^ (-2) = 1 / 6;
  5 ^ (-3) = 1 / 5 ^ 2;
\end{lstlisting}

Exponentiating by -1 will always produce 1, with the exception of 0.

\begin{lstlisting}[language=Python]
  2 ^ (-1) = 1;
  6 ^ (-1) = 1;
  5 ^ (-1) = 1;
  0 ^ (-1) = 0;
\end{lstlisting}

\subsection{Functions}

\subsection{Higher-Order Functions}